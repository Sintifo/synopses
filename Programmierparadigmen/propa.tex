\documentclass[10pt,a4paper]{article}
\author{Sebastian Markgraf}
\title{Programmierparadigmen}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=1100,stretch=10,shrink=10]{microtype}
% activate={true,nocompatibility} - activate protrusion and expansion
% final - enable microtype; use "draft" to disable
% tracking=true, kerning=true, spacing=true - activate these techniques
% factor=1100 - add 10% to the protrusion amount (default is 1000)
% stretch=10, shrink=10 - reduce stretchability/shrinkability (default is 20/20)
\microtypecontext{spacing=nonfrench}

\def\realnumbers{{\rm I\!R}}
\def\naturalnumbers{{\rm I\!N}}
\def\complexnumbers{{\mathbb{C}}}
\def\code#1{\texttt{#1}}

\lstset{language=Haskell,mathescape=true}

\begin{document}
	\pagenumbering{Roman}
	{\let\newpage\relax\maketitle}
	\tableofcontents
	\newpage
	\pagenumbering{arabic}
	\setcounter{page}{1}

        \section{Funktionale Programmierung in Haskell}

        \subsection{Funktion}
        Entspricht in Sprachen wie Haskell der mathematischen Sicht:
        \begin{itemize}
          \item Bildet Element aus Definitions- in Wertebereich ab
          \item Auswertung keine Effekte auf Daten des Programms
          \item Wert von \(f(x)\) alleine von \(x\) abhängig
        \end{itemize}
        Es gibt keine Variablen in Haskell, Zustand über Parameter \& Rückgabewert.  

        \subsection{Funktionsdefinition}
        \code{f x = sin x / x}\\
        Defininiere Funktionen mit Leerzeichen um Parameter zu trennen.\\

        
        \subsection{Rekursive Definitionen}
        Definition mit if-else-then:
        \begin{lstlisting}
          binom n k =
            if (k == 0) || (k == n)
            then 1
            else binom (n-1) (k-1) + binom (n-1) k
        \end{lstlisting}
        Oder mit Type Guard Notation:
        \begin{lstlisting}
          binom n k
            | (k == 0) || (k == n) = 1
            | otherwise = binom (n-1) (k-1) + binom (n-1) k
        \end{lstlisting}
        Vergleichbar mit Mathematischer Notation

        \subsection{Ausführung}
        Ausführung mit \code{ghci}\\
        Programm \code{simple.hs}:
        \begin{lstlisting}
          square x = x * x
          cube x = x * square x
        \end{lstlisting}
        Laden und Ausführen:
        \begin{lstlisting}[language=bash]
          ghci
          :l simple.hs
          cube (1+2)
        \end{lstlisting}

        \subsection{Auswertung}
        Schrittweise ausgewertet
        \begin{itemize}
          \item \(e_1 \Rightarrow e_2\) für einen Schritt
          \item \(e_1 \Rightarrow^+ e_n \) falls \(e_1 \Rightarrow e_2 \Rightarrow ... \Rightarrow e_n\)
        \end{itemize}
        
        \subsection{Akkumulatoren}
        Auswertung von rekursiven Funktionen \(\Rightarrow\) Zwischenausdrücke wachsen mit Eingabegröße.\\
        Deshalb: Verwende Akkumulatoren\\
        Idee: Speichere partielle Ergebnisse
        \begin{lstlisting}
          fakAcc n acc = if (n==0) then acc else fakAcc (n-1) (n*acc)
          fak n = fakAcc n 1
        \end{lstlisting}

        \subsection{Endrekursion}
        Funktion heiß endrekursiv, falls in jedem Zweig der rekursive Aufruf nicht in einen anderen Aufruf eingebettet ist.

        \subsection{Listen}
        Liste ist entweder
        \begin{itemize}
          \item leere Liste \code{[]}, oder
          \item List \code{(x:xs)}, Restlist \code{xs} und Listenkopf \code{x}
        \end{itemize}
        \code{(:)} ist Listenkonstruktor, genannt const.
        Lässt sich zum Pattern Matching auf Listen verwenden.\\
        \textbf{Operationen}
        \begin{itemize}
          \item \code{null l} - Teste ob leer
          \item \code{head} und \code{tail} berechnen Kopf und Restliste.
          \item \code{app left right} - Elemente aus \code{left} gefolgt von Elementen aus \code{right}
          \item \code{rev list} - Elemente aus \code{list} in umgedrehter Reihenfolge
          \item \code{take n l} - Erste \code{n} Elemente von \code{l}
          \item \code{drop n l} - \code{l} ohne erste \code{n} Elemente
        \end{itemize}
          
        \subsection{Pattern Matching}
        Verwende mehrere Gleichungen zur Definition einer Funktion.\\
        Jede Gleichung gibt Struktur für Argumente vor. Erstes passendes Muster wird angewandt.
        Muster sind Konstanten, Variablen oder Konstruktoren.
        \begin{lstlisting}
          maximum [] = error 'empty'
          maximum (x:[]) = x
          maximum (x:xs) = max x (maximum xs)
        \end{lstlisting}


        \subsection{Funktionen höherer Ordnung}
        \textbf{Lambda Notation}
        Schreibe Funktionsparameter auf rechte Seite
        \begin{lstlisting}
          f = \x -> x * x - 3*x
          g = \x y -> x - 2/y
        \end{lstlisting}
        Lassen sich auf Parameter anwenden
        \begin{lstlisting}
          (\x -> x * x) 3 $\Rightarrow$ 3 * 3
        \end{lstlisting}
        \textbf{Defintion}\\
        Funktionen, die andere Funktionen als Parameter erhalten oder Funktionen als Rückgabewerte liefer, heißen Funktionen höherer Ordnung.
        Vgl. Mathematik - Ableitung\\\\
        \textbf{Funktionen als Parameter}\\
        Funktionsanwendung auf Listen:\\
        \code{map :: (s -> t) -> [s] -> t}\\
        Filtern von Listen:\\
        \code{filter :: (t -> Bool) -> [t] -> [t]}\\\\
        \textbf{Funktion als Rückgabewert}\\
        Funktionskomposition: \code{f . g}\\
        n-fache Anwedung: \code{iter :: (t -> t) -> Integer -> (t -> t)}

        \subsection{Currying}
        Ersetzung einer mehrstelligen Funktion durch Schachtelung einstelliger Funktionen\\
        z.B. \(f = \lambda a, b.F(a,b)\) und \(f_c = \lambda a.\lambda b. F(a, b)\)\\
        \(f_c\) kann unterversorgt werden!\\\\
        \textbf{Unterversorgung}\\
        Wende `mehrstellige` Funktionen auf zu wenige Parameter an.

        \subsection{Namensbindung}
        Bindungskonstrukte legen Bedeutung und Geltungsbereich von Variablen fest.
        \begin{itemize}
          \item Globale Bindung durch Defintion
          \item Parameter im Rumpf gebunden
          \item x in Lambda Ausdruck gebunden
        \end{itemize}

        \subsection{Lokale Bindung}
        \textbf{let} ermöglicht Deklarierung in Block.\\
        \textbf{where} vor Allem für Hilfsfunktionen.\\
        \begin{lstlisting}
          let c = 299792458 in m * c * c
          energy m = m * c * c
            where c = 299792458
        \end{lstlisting}

        \subsection{Verdeckung}
        Innere Bindungen verdecken äußere.
        Vorsicht insbesondere bei \code{let} Klauseln!
        \begin{lstlisting}
          unknown = let x = 3 in
                      let x = 3 * x in 4 +x
        \end{lstlisting}
        \code{x} in \code{3 * x} gebunden durch inneres \code{let}
        \(\Rightarrow\) Auswetung terminiert nicht.

        \subsection{Folds}
        Verallgemeinere Summe und andere Operationen auf Listen zu \textit{Initialwert, Operator}.
        \begin{lstlisting}
          foldr op i [] = i
          foldr op i (x:xs) = op x (foldr op i xs)

          foldl op i [] = i
          foldl op i (x:xs) = foldl op (op i x) xs
        \end{lstlisting}
        Gibt selbes Ergebnis, falls Operation assoziativ.\\
        Besonders bei Kurzschlussauswertung empfiehlt sich \code{foldr} zu verwenden, obwohl es nicht die Endrekursion ausnutzt.

        \subsection{List Comprehensions}
        Generierung von Listen \code{\([e | q_1, ..., q_m]\)}, wobei die \code{\(q_i\)} Tests von der Form
        \code{p <- list}, Muster \code{p} und Listenausdruck \code{list}, sind.
\end{document}