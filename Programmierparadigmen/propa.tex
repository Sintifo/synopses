\documentclass[10pt,a4paper]{article}
\author{Sebastian Markgraf}
\title{Programmierparadigmen}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage[a4paper, total={6in, 8in}]{geometry}


\def\realnumbers{{\rm I\!R}}
\def\naturalnumbers{{\rm I\!N}}
\def\complexnumbers{{\mathbb{C}}}
\def\code#1{\texttt{#1}}

\lstset{language=Haskell}

\begin{document}
	\pagenumbering{Roman}
	{\let\newpage\relax\maketitle}
	\tableofcontents
	\newpage
	\pagenumbering{arabic}
	\setcounter{page}{1}

        \section{Funktionale Programmierung in Haskell}

        \subsection{Funktion}
        Entspricht in Sprachen wie Haskell der mathematischen Sicht:
        \begin{itemize}
          \item Bildet Element aus Definitions- in Wertebereich ab
          \item Auswertung keine Effekte auf Daten des Programms
          \item Wert von \(f(x)\) alleine von \(x\) abhängig
        \end{itemize}
        Es gibt keine Variablen in Haskell, Zustand über Parameter \& Rückgabewert.  

        \subsection{Funktionsdefinition}
        \code{f x = sin x / x}\\
        Defininiere Funktionen mit Leerzeichen um Parameter zu trennen.\\

        
        \subsection{Rekursive Definitionen}
        Definition mit if-else-then:
        \begin{lstlisting}
          binom n k =
            if (k == 0) || (k == n)
            then 1
            else binom (n-1) (k-1) + binom (n-1) k
        \end{lstlisting}
        Oder mit Type Guard Notation:
        \begin{lstlisting}
          binom n k
            | (k == 0) || (k == n) = 1
            | otherwise = binom (n-1) (k-1) + binom (n-1) k
        \end{lstlisting}
        Vergleichbar mit Mathematischer Notation

        \subsection{Ausführung}
        Ausführung mit \code{ghci}\\
        Programm \code{simple.hs}:
        \begin{lstlisting}
          square x = x * x
          cube x = x * square x
        \end{lstlisting}
        
        Laden und Ausführen:
        \begin{lstlisting}[language=bash]
          ghci
          :l simple.hs
          cube (1+2)
        \end{lstlisting}

        \subsection{Auswertung}
        Schrittweise ausgewertet
        \begin{itemize}
          \item \(e_1 \Rightarrow e_2\) für einen Schritt
          \item \(e_1 \Rightarrow^+ e_n \) falls \(e_1 \Rightarrow e_2 \Rightarrow ... \Rightarrow e_n\)
        \end{itemize}
        
        
\end{document}